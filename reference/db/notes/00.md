# 00 - Stand Up Environment

#### VERIFY ENVIRONMENT

Check the container status.

```
docker ps -f name=lv --format "table {{.Names}}\t{{.Status}}"
NAMES               STATUS
lv-postgres         Up 6 minutes
lv-vault            Up 6 minutes (healthy)
```


If both show a status of ```Up``` then you can proceed with the challenge.

The credentials generated by the Vault role require a role named ```ro``` that has been granted the ability to read all tables.

Connect to the Postgres database via the CLI within the ```postgres``` container.

```
docker exec -it lv-postgres psql
psql (14.1 (Debian 14.1-1.pgdg110+1))
Type "help" for help.
```

Your system prompt is replaced with a new prompt ```root=#```. Commands issued at this prompt are executed against the Postgres database running within the container.

Create a role named ```ro```.

```
root=# CREATE ROLE ro NOINHERIT;
CREATE ROLE
```

Grant the ability to read all tables to the role named ```ro```.

```
root=# GRANT SELECT ON ALL TABLES IN SCHEMA public TO "ro";
GRANT
root=# \q
```

Login to Vault with the ```admin``` user using the ```userpass``` authentication method.

```
vault login -method=userpass \
  username=admin \
  password=admin-password
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                    Value
---                    -----
token                  s.DuaBLggtOldnt9qSYuNsW6Ry
token_accessor         pDt1qRYR5cI6P6tXkdAqCFpj
token_duration         768h
token_renewable        true
token_policies         ["admin-policy" "default"]
identity_policies      []
policies               ["admin-policy" "default"]
token_meta_username    admin
```

The environment is ready.

####



```
 ls -al
total 104
drwx------ 13 root root  4096 Feb 28 04:54 .
drwxr-xr-x 23 root root  4096 Feb 28 04:53 ..
-rw-r--r--  1 root root   123 Feb 28 04:56 .bash_history
-rw-r--r--  1 root root  1739 Feb 28 04:54 .bashrc
drwx------  2 root root  4096 Sep  9  2020 .cache
drwxr-xr-x  3 root root  4096 Dec  8  2020 .config
drwx------  2 root root  4096 Sep  9  2020 .docker
drwx------  3 root root  4096 Sep  9  2020 .gnupg
-rw-r--r--  1 root root   148 Aug 17  2015 .profile
drwx------  2 root root  4096 Feb 28 04:53 .ssh
drwxr-xr-x  3 root root  4096 Feb 28 04:53 .terraform
drwxr-xr-x  2 root root  4096 Feb 28 04:53 .terraform.d
-rwxrwxrwx  1 root root  2013 Feb 28 04:53 .terraform.lock.hcl
-rw-------  1 root root 14583 Feb 28 04:53 .vimrc
-rw-r--r--  1 root root   920 Feb 28 04:53 admin-policy.hcl
-rw-r--r--  1 root root   114 Feb 28 04:53 apps-policy.hcl
drwxr-xr-x  2 root root  4096 Feb 28 04:53 config
-rw-r--r--  1 root root  2930 Feb 28 04:53 main.tf
-rw-r--r--  1 root root   120 Feb 28 04:53 readonly.sql
drwxr-xr-x  3 root root  4096 Dec  8  2020 snap
drwxr-xr-x  2 root root  4096 Feb 28 04:54 tfstate
drwxr-xr-x  2 root root  4096 Feb 28 04:53 vault-audit-log
-rw-r--r--  1 root root   158 Feb 28 04:53 versions.tf
root@vault-server:~# 
```





```
# terraform show
# data.template_file.vault_configuration:
data "template_file" "vault_configuration" {
    id       = "9c7c7803ac712376e596c32cd56bac7af5c37ab8ccfacb0bb3c4e81e5ca8560e"
    rendered = <<-EOT
        log_level = "trace"
        ui        = true
        
        storage "file" {
          path = "/vault/file"
        }
        
        listener "tcp" {
          address     = "0.0.0.0:8200"
          tls_disable = 1
        }
        
        telemetry {
          dogstatsd_addr                 = "10.42.10.102:8125"
          enable_hostname_label          = true
          disable_hostname               = true
          enable_high_cardinality_labels = "*"
        }
    EOT
    template = <<-EOT
        log_level = "trace"
        ui        = true
        
        storage "file" {
          path = "/vault/file"
        }
        
        listener "tcp" {
          address     = "0.0.0.0:8200"
          tls_disable = 1
        }
        
        telemetry {
          dogstatsd_addr                 = "10.42.10.102:8125"
          enable_hostname_label          = true
          disable_hostname               = true
          enable_high_cardinality_labels = "*"
        }
    EOT
}

# docker_container.postgres:
resource "docker_container" "postgres" {
    attach            = false
    command           = [
        "postgres",
    ]
    cpu_shares        = 0
    entrypoint        = [
        "docker-entrypoint.sh",
    ]
    env               = [
        "POSTGRES_PASSWORD=rootpassword",
        "POSTGRES_USER=root",
    ]
    gateway           = "10.42.10.1"
    hostname          = "lv-postgres"
    id                = "500ed4fc3daebec0ede9cd6670bdddec2a1ae364ff404ef20c23cb61d6f49e42"
    image             = "sha256:da2cb49d7a8d1416cfc2ec6fb47b60112b3a2f276bcf7439ef18e7c505b83fc6"
    init              = false
    ip_address        = "10.42.10.104"
    ip_prefix_length  = 24
    ipc_mode          = "private"
    log_driver        = "json-file"
    logs              = false
    max_retry_count   = 0
    memory            = 0
    memory_swap       = 0
    must_run          = true
    name              = "lv-postgres"
    network_data      = [
        {
            gateway                   = "10.42.10.1"
            global_ipv6_address       = ""
            global_ipv6_prefix_length = 0
            ip_address                = "10.42.10.104"
            ip_prefix_length          = 24
            ipv6_gateway              = ""
            network_name              = "lv-network"
        },
    ]
    network_mode      = "default"
    privileged        = false
    publish_all_ports = false
    read_only         = false
    remove_volumes    = true
    restart           = "no"
    rm                = false
    security_opts     = []
    shm_size          = 64
    start             = true
    stdin_open        = false
    tty               = false

    networks_advanced {
        aliases      = []
        ipv4_address = "10.42.10.104"
        name         = "lv-network"
    }

    ports {
        external = 5432
        internal = 5432
        ip       = "0.0.0.0"
        protocol = "tcp"
    }
}

# docker_container.vault:
resource "docker_container" "vault" {
    attach            = false
    command           = [
        "vault",
        "server",
        "-dev",
        "-dev-root-token-id=root",
        "-dev-listen-address=0.0.0.0:8200",
    ]
    cpu_shares        = 0
    entrypoint        = [
        "docker-entrypoint.sh",
    ]
    env               = [
        "SKIP_CHOWN",
        "VAULT_ADDR=http://127.0.0.1:8200",
    ]
    gateway           = "10.42.10.1"
    hostname          = "lv-vault"
    id                = "a15a800fd8ae767aad6984b0d71a2701a9bd498b061a4671510178879eff4b07"
    image             = "sha256:9bb605f7fffed3a5db4aaa27c80eb0c9b5de898356ebf5e66c7897fce56f29f3"
    init              = false
    ip_address        = "10.42.10.103"
    ip_prefix_length  = 24
    ipc_mode          = "private"
    log_driver        = "json-file"
    logs              = false
    max_retry_count   = 0
    memory            = 0
    memory_swap       = 0
    must_run          = true
    name              = "lv-vault"
    network_data      = [
        {
            gateway                   = "10.42.10.1"
            global_ipv6_address       = ""
            global_ipv6_prefix_length = 0
            ip_address                = "10.42.10.103"
            ip_prefix_length          = 24
            ipv6_gateway              = ""
            network_name              = "lv-network"
        },
    ]
    network_mode      = "default"
    privileged        = false
    publish_all_ports = false
    read_only         = false
    remove_volumes    = true
    restart           = "no"
    rm                = false
    security_opts     = []
    shm_size          = 64
    start             = true
    stdin_open        = false
    tty               = false

    capabilities {
        add  = [
            "IPC_LOCK",
        ]
        drop = []
    }

    healthcheck {
        interval     = "10s"
        retries      = 2
        start_period = "10s"
        test         = [
            "CMD",
            "vault",
            "status",
        ]
        timeout      = "2s"
    }

    networks_advanced {
        aliases      = []
        ipv4_address = "10.42.10.103"
        name         = "lv-network"
    }

    ports {
        external = 8200
        internal = 8200
        ip       = "0.0.0.0"
        protocol = "tcp"
    }
}

# docker_image.postgres:
resource "docker_image" "postgres" {
    id           = "sha256:da2cb49d7a8d1416cfc2ec6fb47b60112b3a2f276bcf7439ef18e7c505b83fc6postgres:14.1"
    keep_locally = true
    latest       = "sha256:da2cb49d7a8d1416cfc2ec6fb47b60112b3a2f276bcf7439ef18e7c505b83fc6"
    name         = "postgres:14.1"
}

# docker_image.vault:
resource "docker_image" "vault" {
    id           = "sha256:9bb605f7fffed3a5db4aaa27c80eb0c9b5de898356ebf5e66c7897fce56f29f3vault:1.9.2"
    keep_locally = true
    latest       = "sha256:9bb605f7fffed3a5db4aaa27c80eb0c9b5de898356ebf5e66c7897fce56f29f3"
    name         = "vault:1.9.2"
}

# docker_network.lvm_network:
resource "docker_network" "lvm_network" {
    attachable  = true
    driver      = "bridge"
    id          = "d21ab35e809a811cd374d6341b57726127d6f2791bac0bc52a47ec13b43741b2"
    ingress     = false
    internal    = false
    ipam_driver = "default"
    ipv6        = false
    name        = "lv-network"
    options     = {}
    scope       = "local"

    ipam_config {
        subnet = "10.42.10.0/24"
    }
}
```